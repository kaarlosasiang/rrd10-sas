import mongoose, { Schema } from "mongoose";

import {
  IReport,
  IReportDocument,
  IReportParameters,
  ReportFormat,
  ReportType,
} from '../shared/interface/IReport.js';

/**
 * Report Parameters Schema
 */
const ReportParametersSchema = new Schema<IReportParameters>(
  {
    startDate: {
      type: Date,
      required: [true, "Start date is required"],
    },
    endDate: {
      type: Date,
      required: [true, "End date is required"],
    },
    accountIds: {
      type: [Schema.Types.ObjectId],
      ref: "Account",
      default: [],
    },
  },
  { _id: false, strict: false }, // Allow additional custom parameters
);

/**
 * Report Schema
 */
const ReportSchema = new Schema<IReport>(
  {
    companyId: {
      type: Schema.Types.ObjectId,
      ref: "Company",
      required: [true, "Company ID is required"],
      index: true,
    },
    reportName: {
      type: String,
      required: [true, "Report name is required"],
      trim: true,
    },
    reportType: {
      type: String,
      required: [true, "Report type is required"],
      enum: {
        values: Object.values(ReportType),
        message: "Invalid report type",
      },
      index: true,
    },
    parameters: {
      type: ReportParametersSchema,
      required: [true, "Parameters are required"],
    },
    generatedData: {
      type: Schema.Types.Mixed,
      required: [true, "Generated data is required"],
    },
    generatedBy: {
      type: Schema.Types.ObjectId,
      ref: "User",
      required: [true, "Generated by user is required"],
      index: true,
    },
    generatedAt: {
      type: Date,
      required: [true, "Generated at date is required"],
      default: Date.now,
      index: true,
    },
    format: {
      type: String,
      required: [true, "Format is required"],
      enum: {
        values: Object.values(ReportFormat),
        message: "Invalid format",
      },
    },
    filePath: {
      type: String,
      required: [true, "File path is required"],
      trim: true,
    },
  },
  {
    timestamps: true,
    collection: "reports",
  },
);

/**
 * Indexes for performance
 */
ReportSchema.index({ companyId: 1, reportType: 1 });
ReportSchema.index({ companyId: 1, generatedAt: -1 });
ReportSchema.index({ generatedBy: 1, generatedAt: -1 });
ReportSchema.index({ "parameters.startDate": 1, "parameters.endDate": 1 });

/**
 * Pre-save validation
 */
ReportSchema.pre("save", function () {
  // Validate date range
  if (this.parameters.endDate < this.parameters.startDate) {
    throw new Error("End date must be after start date");
  }
});

/**
 * Virtual: Date range display
 */
ReportSchema.virtual("dateRange").get(function () {
  const startDate = this.parameters.startDate.toLocaleDateString();
  const endDate = this.parameters.endDate.toLocaleDateString();
  return `${startDate} - ${endDate}`;
});

/**
 * Virtual: File size (would need actual file stats in real implementation)
 */
ReportSchema.virtual("fileName").get(function () {
  return this.filePath.split("/").pop();
});

/**
 * Instance method: Check if report is expired (older than 30 days)
 */
ReportSchema.methods.isExpired = function (daysToExpire: number = 30): boolean {
  const expirationDate = new Date();
  expirationDate.setDate(expirationDate.getDate() - daysToExpire);
  return this.generatedAt < expirationDate;
};

/**
 * Instance method: Check if report is recent (within last 7 days)
 */
ReportSchema.methods.isRecent = function (days: number = 7): boolean {
  const recentDate = new Date();
  recentDate.setDate(recentDate.getDate() - days);
  return this.generatedAt >= recentDate;
};

/**
 * Static method: Find reports by company
 */
ReportSchema.statics.findByCompany = function (
  companyId: mongoose.Types.ObjectId,
  limit: number = 50,
) {
  return this.find({ companyId })
    .sort({ generatedAt: -1 })
    .limit(limit)
    .populate("generatedBy", "firstName lastName email");
};

/**
 * Static method: Find reports by type
 */
ReportSchema.statics.findByType = function (
  companyId: mongoose.Types.ObjectId,
  reportType: ReportType,
  limit: number = 50,
) {
  return this.find({ companyId, reportType })
    .sort({ generatedAt: -1 })
    .limit(limit)
    .populate("generatedBy", "firstName lastName email");
};

/**
 * Static method: Find reports by user
 */
ReportSchema.statics.findByUser = function (
  userId: mongoose.Types.ObjectId,
  limit: number = 50,
) {
  return this.find({ generatedBy: userId })
    .sort({ generatedAt: -1 })
    .limit(limit)
    .populate("companyId", "companyName");
};

/**
 * Static method: Find reports by date range
 */
ReportSchema.statics.findByDateRange = function (
  companyId: mongoose.Types.ObjectId,
  startDate: Date,
  endDate: Date,
) {
  return this.find({
    companyId,
    "parameters.startDate": { $gte: startDate },
    "parameters.endDate": { $lte: endDate },
  })
    .sort({ generatedAt: -1 })
    .populate("generatedBy", "firstName lastName email");
};

/**
 * Static method: Clean up expired reports
 */
ReportSchema.statics.cleanupExpiredReports = async function (
  daysToExpire: number = 30,
) {
  const expirationDate = new Date();
  expirationDate.setDate(expirationDate.getDate() - daysToExpire);

  const expiredReports = await this.find({
    generatedAt: { $lt: expirationDate },
  });

  // In real implementation, you would also delete the physical files
  // from the file system before deleting the database records

  return this.deleteMany({
    generatedAt: { $lt: expirationDate },
  });
};

/**
 * Static method: Get report statistics
 */
ReportSchema.statics.getReportStatistics = function (
  companyId: mongoose.Types.ObjectId,
) {
  return this.aggregate([
    { $match: { companyId } },
    {
      $group: {
        _id: "$reportType",
        count: { $sum: 1 },
        lastGenerated: { $max: "$generatedAt" },
      },
    },
    { $sort: { count: -1 } },
  ]);
};

/**
 * Static method: Get most generated reports
 */
ReportSchema.statics.getMostGeneratedReports = function (
  companyId: mongoose.Types.ObjectId,
  limit: number = 5,
) {
  return this.aggregate([
    { $match: { companyId } },
    {
      $group: {
        _id: "$reportType",
        count: { $sum: 1 },
        lastGenerated: { $max: "$generatedAt" },
      },
    },
    { $sort: { count: -1 } },
    { $limit: limit },
  ]);
};

/**
 * Export the model
 */
export const Report =
  (mongoose.models.Report as mongoose.Model<IReportDocument>) ||
  mongoose.model<IReportDocument>("Report", ReportSchema as any);
